<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>o2scl_linalg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>O2scl&#160;User's&#160;Guide</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">o2scl_linalg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The namespace for linear algebra classes and functions.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>See <a class="el" href="linalg_section.html">Linear Algebra</a> for more complete information about linear algebra in O<span style='position: relative; top: 0.3em; font-size: 0.8em'>2</span>scl .</p>
<p>This namespace documentation is in the file <code>src/base/cblas.h</code> </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1lanczos.html">lanczos</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lanczos diagonalization.  <a href="classo2scl__linalg_1_1lanczos.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver.html">linear_solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic solver for the linear system <img class="formulaInl" alt="$ A x = b $" src="form_278.png"/> [abstract base].  <a href="classo2scl__linalg_1_1linear__solver.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__LU.html">linear_solver_LU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic linear solver using LU decomposition.  <a href="classo2scl__linalg_1_1linear__solver__LU.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__QR.html">linear_solver_QR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic linear solver using QR decomposition.  <a href="classo2scl__linalg_1_1linear__solver__QR.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__HH.html">linear_solver_HH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic Householder linear solver.  <a href="classo2scl__linalg_1_1linear__solver__HH.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__arma.html">linear_solver_arma</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Armadillo linear solver.  <a href="classo2scl__linalg_1_1linear__solver__arma.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__eigen__houseQR.html">linear_solver_eigen_houseQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen linear solver using QR decomposition with column pivoting.  <a href="classo2scl__linalg_1_1linear__solver__eigen__houseQR.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__eigen__colQR.html">linear_solver_eigen_colQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen linear solver using QR decomposition with column pivoting.  <a href="classo2scl__linalg_1_1linear__solver__eigen__colQR.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__eigen__fullQR.html">linear_solver_eigen_fullQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen linear solver using QR decomposition with full pivoting.  <a href="classo2scl__linalg_1_1linear__solver__eigen__fullQR.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__eigen__partLU.html">linear_solver_eigen_partLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen linear solver using LU decomposition with partial pivoting.  <a href="classo2scl__linalg_1_1linear__solver__eigen__partLU.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__eigen__fullLU.html">linear_solver_eigen_fullLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen linear solver using LU decomposition with full pivoting.  <a href="classo2scl__linalg_1_1linear__solver__eigen__fullLU.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__eigen__LLT.html">linear_solver_eigen_LLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen linear solver using LLT decomposition with full pivoting.  <a href="classo2scl__linalg_1_1linear__solver__eigen__LLT.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1linear__solver__eigen__LDLT.html">linear_solver_eigen_LDLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen linear solver using LDLT decomposition with full pivoting.  <a href="classo2scl__linalg_1_1linear__solver__eigen__LDLT.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1ubvector__2__mem.html">ubvector_2_mem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation object for 2 arrays of equal size.  <a href="classo2scl__linalg_1_1ubvector__2__mem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1ubvector__4__mem.html">ubvector_4_mem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation object for 4 arrays of equal size.  <a href="classo2scl__linalg_1_1ubvector__4__mem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classo2scl__linalg_1_1ubvector__5__mem.html">ubvector_5_mem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation object for 5 arrays of equal size.  <a href="classo2scl__linalg_1_1ubvector__5__mem.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a187185f2c949c9122d30018109d29054"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a187185f2c949c9122d30018109d29054"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a187185f2c949c9122d30018109d29054">bidiag_decomp</a> (size_t M, size_t N, mat_t &amp;A, vec_t &amp;tau_U, vec2_t &amp;tau_V)</td></tr>
<tr class="memdesc:a187185f2c949c9122d30018109d29054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factor a matrix into bidiagonal form.  <a href="#a187185f2c949c9122d30018109d29054">More...</a><br/></td></tr>
<tr class="separator:a187185f2c949c9122d30018109d29054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab3bc3b12150e0a8b158fec36b5320d"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class vec_t , class mat2_t , class vec2_t , class mat3_t , class vec3_t , class vec4_t &gt; </td></tr>
<tr class="memitem:a3ab3bc3b12150e0a8b158fec36b5320d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a3ab3bc3b12150e0a8b158fec36b5320d">bidiag_unpack</a> (size_t M, size_t N, const mat_t &amp;A, const vec_t &amp;tau_U, mat2_t &amp;U, const vec2_t &amp;tau_V, mat3_t &amp;V, vec3_t &amp;diag, vec4_t &amp;superdiag)</td></tr>
<tr class="memdesc:a3ab3bc3b12150e0a8b158fec36b5320d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a matrix <code>A</code> with the bidiagonal decomposition and create matrices <code>U</code>, <code>V</code>, diagonal <code>diag</code> and superdiagonal <code>superdiag</code>.  <a href="#a3ab3bc3b12150e0a8b158fec36b5320d">More...</a><br/></td></tr>
<tr class="separator:a3ab3bc3b12150e0a8b158fec36b5320d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851f79ebab8ed7f2b472712b3496293b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a851f79ebab8ed7f2b472712b3496293b"></a>
template&lt;class mat_t , class vec_t , class vec2_t , class mat2_t &gt; </td></tr>
<tr class="memitem:a851f79ebab8ed7f2b472712b3496293b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a851f79ebab8ed7f2b472712b3496293b">bidiag_unpack2</a> (size_t M, size_t N, mat_t &amp;A, vec_t &amp;tau_U, vec2_t &amp;tau_V, mat2_t &amp;V)</td></tr>
<tr class="memdesc:a851f79ebab8ed7f2b472712b3496293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack a matrix <code>A</code> with the bidiagonal decomposition and create matrix <code>V</code>. <br/></td></tr>
<tr class="separator:a851f79ebab8ed7f2b472712b3496293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dda44a1c2252a5ea74747ac0d74fa7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad1dda44a1c2252a5ea74747ac0d74fa7"></a>
template&lt;class mat_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:ad1dda44a1c2252a5ea74747ac0d74fa7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#ad1dda44a1c2252a5ea74747ac0d74fa7">bidiag_unpack_B</a> (size_t M, size_t N, const mat_t &amp;A, vec_t &amp;diag, vec2_t &amp;superdiag)</td></tr>
<tr class="memdesc:ad1dda44a1c2252a5ea74747ac0d74fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack the diagonal and superdiagonal of the bidiagonal decomposition of <code>A</code> into <code>diag</code> and <code>superdiag</code>. <br/></td></tr>
<tr class="separator:ad1dda44a1c2252a5ea74747ac0d74fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d166572a1cd2e6da85f5d0d50090a61"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a4d166572a1cd2e6da85f5d0d50090a61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a4d166572a1cd2e6da85f5d0d50090a61">cholesky_decomp</a> (const size_t M, mat_t &amp;A)</td></tr>
<tr class="memdesc:a4d166572a1cd2e6da85f5d0d50090a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the in-place Cholesky decomposition of a symmetric positive-definite square matrix.  <a href="#a4d166572a1cd2e6da85f5d0d50090a61">More...</a><br/></td></tr>
<tr class="separator:a4d166572a1cd2e6da85f5d0d50090a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7d4da90e7f9526d06e94c30a3d9d48"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a1c7d4da90e7f9526d06e94c30a3d9d48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a1c7d4da90e7f9526d06e94c30a3d9d48">cholesky_solve</a> (const size_t N, const mat_t &amp;LLT, const vec_t &amp;b, vec2_t &amp;x)</td></tr>
<tr class="memdesc:a1c7d4da90e7f9526d06e94c30a3d9d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a symmetric positive-definite linear system after a Cholesky decomposition.  <a href="#a1c7d4da90e7f9526d06e94c30a3d9d48">More...</a><br/></td></tr>
<tr class="separator:a1c7d4da90e7f9526d06e94c30a3d9d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94edf124f826a7ebe32912d458375b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab94edf124f826a7ebe32912d458375b4"></a>
template&lt;class mat_t , class vec_t &gt; </td></tr>
<tr class="memitem:ab94edf124f826a7ebe32912d458375b4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#ab94edf124f826a7ebe32912d458375b4">cholesky_svx</a> (const size_t N, const mat_t &amp;LLT, vec_t &amp;x)</td></tr>
<tr class="memdesc:ab94edf124f826a7ebe32912d458375b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system in place using a Cholesky decomposition. <br/></td></tr>
<tr class="separator:ab94edf124f826a7ebe32912d458375b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce5f0f6fbab801df7fc63f1200ac027"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:afce5f0f6fbab801df7fc63f1200ac027"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#afce5f0f6fbab801df7fc63f1200ac027">cholesky_invert</a> (const size_t N, mat_t &amp;LLT)</td></tr>
<tr class="memdesc:afce5f0f6fbab801df7fc63f1200ac027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of a symmetric positive definite matrix given the Cholesky decomposition.  <a href="#afce5f0f6fbab801df7fc63f1200ac027">More...</a><br/></td></tr>
<tr class="separator:afce5f0f6fbab801df7fc63f1200ac027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af106094528bef943dfe75c2541194185"><td class="memTemplParams" colspan="2"><a class="anchor" id="af106094528bef943dfe75c2541194185"></a>
template&lt;class mat_t , class vec_t &gt; </td></tr>
<tr class="memitem:af106094528bef943dfe75c2541194185"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cholesky_decomp_unit</b> (const size_t N, mat_t &amp;A, vec_t &amp;D)</td></tr>
<tr class="separator:af106094528bef943dfe75c2541194185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c813de822088b1c8ac03818164f2d74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a1c813de822088b1c8ac03818164f2d74">create_givens</a> (const double a, const double b, double &amp;c, double &amp;s)</td></tr>
<tr class="memdesc:a1c813de822088b1c8ac03818164f2d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Givens rotation matrix.  <a href="#a1c813de822088b1c8ac03818164f2d74">More...</a><br/></td></tr>
<tr class="separator:a1c813de822088b1c8ac03818164f2d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea3190e9e6dc21e8fa4a3e832848318"><td class="memTemplParams" colspan="2">template&lt;class mat1_t , class mat2_t &gt; </td></tr>
<tr class="memitem:a7ea3190e9e6dc21e8fa4a3e832848318"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a7ea3190e9e6dc21e8fa4a3e832848318">apply_givens_qr</a> (size_t M, size_t N, mat1_t &amp;Q, mat2_t &amp;R, size_t i, size_t j, double c, double s)</td></tr>
<tr class="memdesc:a7ea3190e9e6dc21e8fa4a3e832848318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rotation to matrices from the QR decomposition.  <a href="#a7ea3190e9e6dc21e8fa4a3e832848318">More...</a><br/></td></tr>
<tr class="separator:a7ea3190e9e6dc21e8fa4a3e832848318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9255c444095d57e7c3119efdf558fdf3"><td class="memTemplParams" colspan="2">template&lt;class mat1_t , class mat2_t &gt; </td></tr>
<tr class="memitem:a9255c444095d57e7c3119efdf558fdf3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a9255c444095d57e7c3119efdf558fdf3">apply_givens_lq</a> (size_t M, size_t N, mat1_t &amp;Q, mat2_t &amp;L, size_t i, size_t j, double c, double s)</td></tr>
<tr class="memdesc:a9255c444095d57e7c3119efdf558fdf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rotation to matrices from the LQ decomposition.  <a href="#a9255c444095d57e7c3119efdf558fdf3">More...</a><br/></td></tr>
<tr class="separator:a9255c444095d57e7c3119efdf558fdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a6ec5f3a3de8522a507b69a1a2fbd6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38a6ec5f3a3de8522a507b69a1a2fbd6"></a>
template&lt;class vec_t &gt; </td></tr>
<tr class="memitem:a38a6ec5f3a3de8522a507b69a1a2fbd6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a38a6ec5f3a3de8522a507b69a1a2fbd6">apply_givens_vec</a> (vec_t &amp;v, size_t i, size_t j, double c, double s)</td></tr>
<tr class="memdesc:a38a6ec5f3a3de8522a507b69a1a2fbd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a rotation to a vector, <img class="formulaInl" alt="$ v \rightarrow G^{T} v $" src="form_273.png"/>. <br/></td></tr>
<tr class="separator:a38a6ec5f3a3de8522a507b69a1a2fbd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1780213a3f89789b6c7da494247c4f"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class vec_t &gt; </td></tr>
<tr class="memitem:a8a1780213a3f89789b6c7da494247c4f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a8a1780213a3f89789b6c7da494247c4f">HH_svx</a> (size_t N, size_t M, mat_t &amp;A, vec_t &amp;x)</td></tr>
<tr class="memdesc:a8a1780213a3f89789b6c7da494247c4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system after Householder decomposition in place.  <a href="#a8a1780213a3f89789b6c7da494247c4f">More...</a><br/></td></tr>
<tr class="separator:a8a1780213a3f89789b6c7da494247c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af298e12e53dde2d5ee4cb5eaa9e4ee76"><td class="memTemplParams" colspan="2"><a class="anchor" id="af298e12e53dde2d5ee4cb5eaa9e4ee76"></a>
template&lt;class mat_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:af298e12e53dde2d5ee4cb5eaa9e4ee76"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#af298e12e53dde2d5ee4cb5eaa9e4ee76">HH_solve</a> (size_t n, mat_t &amp;A, const vec_t &amp;b, vec2_t &amp;x)</td></tr>
<tr class="memdesc:af298e12e53dde2d5ee4cb5eaa9e4ee76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve linear system after Householder decomposition. <br/></td></tr>
<tr class="separator:af298e12e53dde2d5ee4cb5eaa9e4ee76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5218da1d1a3b97518afcd63eeb7c4b96"><td class="memTemplParams" colspan="2">template&lt;class vec_t &gt; </td></tr>
<tr class="memitem:a5218da1d1a3b97518afcd63eeb7c4b96"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a5218da1d1a3b97518afcd63eeb7c4b96">householder_transform</a> (const size_t n, vec_t &amp;v)</td></tr>
<tr class="memdesc:a5218da1d1a3b97518afcd63eeb7c4b96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the vector <code>v</code> with a Householder vector and a coefficient tau that annihilates <code>v[1]</code> through <code>v[n-1]</code> (inclusive)  <a href="#a5218da1d1a3b97518afcd63eeb7c4b96">More...</a><br/></td></tr>
<tr class="separator:a5218da1d1a3b97518afcd63eeb7c4b96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902cb2a01e9961b5745812a46123b17a"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a902cb2a01e9961b5745812a46123b17a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a902cb2a01e9961b5745812a46123b17a">householder_transform_subcol</a> (mat_t &amp;A, const size_t ir, const size_t ic, const size_t M)</td></tr>
<tr class="memdesc:a902cb2a01e9961b5745812a46123b17a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Householder transform of a vector formed with <code>n</code> rows of a column of a matrix.  <a href="#a902cb2a01e9961b5745812a46123b17a">More...</a><br/></td></tr>
<tr class="separator:a902cb2a01e9961b5745812a46123b17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173c7179cb0a5be576e9034ca75066c3"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a173c7179cb0a5be576e9034ca75066c3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a173c7179cb0a5be576e9034ca75066c3">householder_transform_subrow</a> (mat_t &amp;A, const size_t ir, const size_t ic, const size_t N)</td></tr>
<tr class="memdesc:a173c7179cb0a5be576e9034ca75066c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Householder transform of a vector formed with the last <code>n</code> columns of a row of a matrix.  <a href="#a173c7179cb0a5be576e9034ca75066c3">More...</a><br/></td></tr>
<tr class="separator:a173c7179cb0a5be576e9034ca75066c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb8926a8b6dbc52acfb23bef0c9a9c2"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class mat_t &gt; </td></tr>
<tr class="memitem:acdb8926a8b6dbc52acfb23bef0c9a9c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#acdb8926a8b6dbc52acfb23bef0c9a9c2">householder_hm</a> (const size_t M, const size_t N, double tau, const vec_t &amp;v, mat_t &amp;A)</td></tr>
<tr class="memdesc:acdb8926a8b6dbc52acfb23bef0c9a9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Householder transformation <img class="formulaInl" alt="$ (v,\tau) $" src="form_275.png"/> to matrix <img class="formulaInl" alt="$ A $" src="form_276.png"/> of size <code>(M,N)</code>  <a href="#acdb8926a8b6dbc52acfb23bef0c9a9c2">More...</a><br/></td></tr>
<tr class="separator:acdb8926a8b6dbc52acfb23bef0c9a9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d082487242d5d892551ab730f7126f8"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a0d082487242d5d892551ab730f7126f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a0d082487242d5d892551ab730f7126f8">householder_hm_subcol</a> (mat_t &amp;M, const size_t ir, const size_t ic, const size_t nr, const size_t nc, const mat_t &amp;M2, const size_t ir2, const size_t ic2, double tau)</td></tr>
<tr class="memdesc:a0d082487242d5d892551ab730f7126f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Householder transformation to the lower-right part of <code>M</code> when the transformation is stored in a column of <code>M2</code>.  <a href="#a0d082487242d5d892551ab730f7126f8">More...</a><br/></td></tr>
<tr class="separator:a0d082487242d5d892551ab730f7126f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208ce32bd2874399535912e203056e59"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a208ce32bd2874399535912e203056e59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a208ce32bd2874399535912e203056e59">householder_hm_subrow</a> (mat_t &amp;M, const size_t ir, const size_t ic, const size_t nr, const size_t nc, const mat_t &amp;M2, const size_t ir2, const size_t ic2, double tau)</td></tr>
<tr class="memdesc:a208ce32bd2874399535912e203056e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Householder transformation to the lower-right part of <code>M</code> when the transformation is stored in a row of <code>M2</code>.  <a href="#a208ce32bd2874399535912e203056e59">More...</a><br/></td></tr>
<tr class="separator:a208ce32bd2874399535912e203056e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359717a04dd10c9fc87bae053523cf2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a359717a04dd10c9fc87bae053523cf2f"></a>
template&lt;class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a359717a04dd10c9fc87bae053523cf2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a359717a04dd10c9fc87bae053523cf2f">householder_hv</a> (const size_t N, double tau, const vec_t &amp;v, vec2_t &amp;w)</td></tr>
<tr class="memdesc:a359717a04dd10c9fc87bae053523cf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Householder transformation <code>v</code> to vector <code>w</code>. <br/></td></tr>
<tr class="separator:a359717a04dd10c9fc87bae053523cf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9031d54a0dd408080bea7d148f5762"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class vec_t &gt; </td></tr>
<tr class="memitem:a1e9031d54a0dd408080bea7d148f5762"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a1e9031d54a0dd408080bea7d148f5762">householder_hv_subcol</a> (const mat_t &amp;A, vec_t &amp;w, double tau, const size_t ie, const size_t N)</td></tr>
<tr class="memdesc:a1e9031d54a0dd408080bea7d148f5762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Householder transformation <code>v</code> to vector <code>w</code> where <code>v</code> is stored as a column in a matrix <code>A</code>.  <a href="#a1e9031d54a0dd408080bea7d148f5762">More...</a><br/></td></tr>
<tr class="separator:a1e9031d54a0dd408080bea7d148f5762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e6a0eb6805d4b9a790edb644854dd5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a37e6a0eb6805d4b9a790edb644854dd5"></a>
template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a37e6a0eb6805d4b9a790edb644854dd5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a37e6a0eb6805d4b9a790edb644854dd5">householder_hm1</a> (const size_t M, const size_t N, double tau, mat_t &amp;A)</td></tr>
<tr class="memdesc:a37e6a0eb6805d4b9a790edb644854dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Householder transformation <img class="formulaInl" alt="$ (v,\tau) $" src="form_275.png"/> to a matrix being build up from the identity matrix, using the first column of A as a Householder vector. <br/></td></tr>
<tr class="separator:a37e6a0eb6805d4b9a790edb644854dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4925d6f9b14e01dc75edab912634f9"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:acc4925d6f9b14e01dc75edab912634f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#acc4925d6f9b14e01dc75edab912634f9">householder_hm1_sub</a> (const size_t M, const size_t N, double tau, mat_t &amp;A, size_t ir, size_t ic)</td></tr>
<tr class="memdesc:acc4925d6f9b14e01dc75edab912634f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Householder transformation <img class="formulaInl" alt="$ (v,\tau) $" src="form_275.png"/> to a matrix being build up from the identity matrix, using the first column of A as a Householder vector.  <a href="#acc4925d6f9b14e01dc75edab912634f9">More...</a><br/></td></tr>
<tr class="separator:acc4925d6f9b14e01dc75edab912634f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3db065b875a1b873c42c5c790d1f0e2"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa3db065b875a1b873c42c5c790d1f0e2"></a>
template&lt;class vec_t , class mat_t &gt; </td></tr>
<tr class="memitem:aa3db065b875a1b873c42c5c790d1f0e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#aa3db065b875a1b873c42c5c790d1f0e2">householder_mh</a> (const size_t M, const size_t N, double tau, const vec_t &amp;v, mat_t &amp;A)</td></tr>
<tr class="memdesc:aa3db065b875a1b873c42c5c790d1f0e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Householder transformation <code>(v,tau)</code> to the right-hand side of the matrix <code>A</code>. <br/></td></tr>
<tr class="separator:aa3db065b875a1b873c42c5c790d1f0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d49bbb28e37fcb88408cd58854bd77"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat2_t &gt; </td></tr>
<tr class="memitem:a88d49bbb28e37fcb88408cd58854bd77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a88d49bbb28e37fcb88408cd58854bd77">householder_mh_subrow</a> (mat_t &amp;M, const size_t ir, const size_t ic, const size_t nr, const size_t nc, const mat2_t &amp;M2, const size_t ir2, const size_t ic2, double tau)</td></tr>
<tr class="memdesc:a88d49bbb28e37fcb88408cd58854bd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply the Householder transformation <code>(v,tau)</code> to the right-hand side of the matrix <code>A</code>.  <a href="#a88d49bbb28e37fcb88408cd58854bd77">More...</a><br/></td></tr>
<tr class="separator:a88d49bbb28e37fcb88408cd58854bd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e075fbd9d9aaddce28df94fcd4baf7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac1e075fbd9d9aaddce28df94fcd4baf7"></a>
template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:ac1e075fbd9d9aaddce28df94fcd4baf7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#ac1e075fbd9d9aaddce28df94fcd4baf7">diagonal_has_zero</a> (const size_t N, mat_t &amp;A)</td></tr>
<tr class="memdesc:ac1e075fbd9d9aaddce28df94fcd4baf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if at least one of the elements in the diagonal is zero. <br/></td></tr>
<tr class="separator:ac1e075fbd9d9aaddce28df94fcd4baf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5973786eb590c5b078d03d763c5054c"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:aa5973786eb590c5b078d03d763c5054c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#aa5973786eb590c5b078d03d763c5054c">LU_decomp</a> (const size_t N, mat_t &amp;A, <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;p, int &amp;signum)</td></tr>
<tr class="memdesc:aa5973786eb590c5b078d03d763c5054c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the LU decomposition of the matrix <code>A</code>.  <a href="#aa5973786eb590c5b078d03d763c5054c">More...</a><br/></td></tr>
<tr class="separator:aa5973786eb590c5b078d03d763c5054c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6fa6e1a27d9c31b8ee92b1341b01d1"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class vec_t &gt; </td></tr>
<tr class="memitem:abb6fa6e1a27d9c31b8ee92b1341b01d1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#abb6fa6e1a27d9c31b8ee92b1341b01d1">LU_svx</a> (const size_t N, const mat_t &amp;LU, const <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;p, vec_t &amp;x)</td></tr>
<tr class="memdesc:abb6fa6e1a27d9c31b8ee92b1341b01d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system after LU decomposition in place.  <a href="#abb6fa6e1a27d9c31b8ee92b1341b01d1">More...</a><br/></td></tr>
<tr class="separator:abb6fa6e1a27d9c31b8ee92b1341b01d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a918ae5c2f983de9835b2bf32e8321"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat_row_t &gt; </td></tr>
<tr class="memitem:a90a918ae5c2f983de9835b2bf32e8321"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a90a918ae5c2f983de9835b2bf32e8321">LU_decomp_alt</a> (const size_t N, mat_t &amp;A, <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;p, int &amp;signum)</td></tr>
<tr class="memdesc:a90a918ae5c2f983de9835b2bf32e8321"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alternate form of LU decomposition with matrix row objects.  <a href="#a90a918ae5c2f983de9835b2bf32e8321">More...</a><br/></td></tr>
<tr class="separator:a90a918ae5c2f983de9835b2bf32e8321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6061c9646e78d3cd469fe5a8f31d5c8e"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a6061c9646e78d3cd469fe5a8f31d5c8e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a6061c9646e78d3cd469fe5a8f31d5c8e">LU_solve</a> (const size_t N, const mat_t &amp;LU, const <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;p, const vec_t &amp;b, vec2_t &amp;x)</td></tr>
<tr class="memdesc:a6061c9646e78d3cd469fe5a8f31d5c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a linear system after LU decomposition.  <a href="#a6061c9646e78d3cd469fe5a8f31d5c8e">More...</a><br/></td></tr>
<tr class="separator:a6061c9646e78d3cd469fe5a8f31d5c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e422d4448433a6182da5ff37d21ca8f"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat2_t , class vec_t , class vec2_t , class vec3_t &gt; </td></tr>
<tr class="memitem:a4e422d4448433a6182da5ff37d21ca8f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a4e422d4448433a6182da5ff37d21ca8f">LU_refine</a> (const size_t N, const mat_t &amp;A, const mat2_t &amp;LU, const <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;p, const vec_t &amp;b, vec2_t &amp;x, vec3_t &amp;residual)</td></tr>
<tr class="memdesc:a4e422d4448433a6182da5ff37d21ca8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refine the solution of a linear system.  <a href="#a4e422d4448433a6182da5ff37d21ca8f">More...</a><br/></td></tr>
<tr class="separator:a4e422d4448433a6182da5ff37d21ca8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ceda387c6125f2daaa3ec5ff07bca4"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat2_t , class mat_col_t &gt; </td></tr>
<tr class="memitem:af8ceda387c6125f2daaa3ec5ff07bca4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#af8ceda387c6125f2daaa3ec5ff07bca4">LU_invert</a> (const size_t N, const mat_t &amp;LU, const <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;p, mat2_t &amp;inverse)</td></tr>
<tr class="memdesc:af8ceda387c6125f2daaa3ec5ff07bca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of a matrix from its LU decomposition.  <a href="#af8ceda387c6125f2daaa3ec5ff07bca4">More...</a><br/></td></tr>
<tr class="separator:af8ceda387c6125f2daaa3ec5ff07bca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7955241fbd4a975f2206f4a6a7d012ad"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a7955241fbd4a975f2206f4a6a7d012ad"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a7955241fbd4a975f2206f4a6a7d012ad">LU_det</a> (const size_t N, const mat_t &amp;LU, int signum)</td></tr>
<tr class="memdesc:a7955241fbd4a975f2206f4a6a7d012ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the determinant of a matrix from its LU decomposition.  <a href="#a7955241fbd4a975f2206f4a6a7d012ad">More...</a><br/></td></tr>
<tr class="separator:a7955241fbd4a975f2206f4a6a7d012ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff6c76948a6ff9e9e5e4d8f3e318a4e"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a1ff6c76948a6ff9e9e5e4d8f3e318a4e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a1ff6c76948a6ff9e9e5e4d8f3e318a4e">LU_lndet</a> (const size_t N, const mat_t &amp;LU)</td></tr>
<tr class="memdesc:a1ff6c76948a6ff9e9e5e4d8f3e318a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the logarithm of the absolute value of the determinant of a matrix from its LU decomposition.  <a href="#a1ff6c76948a6ff9e9e5e4d8f3e318a4e">More...</a><br/></td></tr>
<tr class="separator:a1ff6c76948a6ff9e9e5e4d8f3e318a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bee71f59276e5382c14d3f55dd3b65d"><td class="memTemplParams" colspan="2">template&lt;class mat_t &gt; </td></tr>
<tr class="memitem:a5bee71f59276e5382c14d3f55dd3b65d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a5bee71f59276e5382c14d3f55dd3b65d">LU_sgndet</a> (const size_t N, const mat_t &amp;LU, int signum)</td></tr>
<tr class="memdesc:a5bee71f59276e5382c14d3f55dd3b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the sign of the determinant of a matrix from its LU decomposition.  <a href="#a5bee71f59276e5382c14d3f55dd3b65d">More...</a><br/></td></tr>
<tr class="separator:a5bee71f59276e5382c14d3f55dd3b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93018c00cee28c8c8b9cd5b21ecc682f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93018c00cee28c8c8b9cd5b21ecc682f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a93018c00cee28c8c8b9cd5b21ecc682f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a93018c00cee28c8c8b9cd5b21ecc682f">QR_decomp_unpack&lt; arma::mat, arma::mat, arma::mat &gt;</a> (const size_t M, const size_t N, arma::mat &amp;A, arma::mat &amp;Q, arma::mat &amp;R)</td></tr>
<tr class="memdesc:a93018c00cee28c8c8b9cd5b21ecc682f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Armadillo specialization of <a class="el" href="namespaceo2scl__linalg.html#aab670dc686bfdb814364471e15fec039">QR_decomp_unpack()</a>. <br/></td></tr>
<tr class="separator:a93018c00cee28c8c8b9cd5b21ecc682f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8813376d2e48c84f134a5880d5b5bc19"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8813376d2e48c84f134a5880d5b5bc19"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8813376d2e48c84f134a5880d5b5bc19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a8813376d2e48c84f134a5880d5b5bc19">QR_decomp_unpack&lt; Eigen::MatrixXd, Eigen::MatrixXd, Eigen::MatrixXd &gt;</a> (const size_t M, const size_t N, Eigen::MatrixXd &amp;A, Eigen::MatrixXd &amp;Q, Eigen::MatrixXd &amp;R)</td></tr>
<tr class="memdesc:a8813376d2e48c84f134a5880d5b5bc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigen specialization of <a class="el" href="namespaceo2scl__linalg.html#aab670dc686bfdb814364471e15fec039">QR_decomp_unpack()</a>. <br/></td></tr>
<tr class="separator:a8813376d2e48c84f134a5880d5b5bc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d84ed3a5e0bff52f863d056ba0894b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac9d84ed3a5e0bff52f863d056ba0894b"></a>
template&lt;class mat_t , class vec_t &gt; </td></tr>
<tr class="memitem:ac9d84ed3a5e0bff52f863d056ba0894b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#ac9d84ed3a5e0bff52f863d056ba0894b">QR_decomp</a> (size_t M, size_t N, mat_t &amp;A, vec_t &amp;tau)</td></tr>
<tr class="memdesc:ac9d84ed3a5e0bff52f863d056ba0894b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the QR decomposition of matrix <code>A</code>. <br/></td></tr>
<tr class="separator:ac9d84ed3a5e0bff52f863d056ba0894b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22786228846e8f4ff6d5f9db89d1f699"><td class="memTemplParams" colspan="2"><a class="anchor" id="a22786228846e8f4ff6d5f9db89d1f699"></a>
template&lt;class mat_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a22786228846e8f4ff6d5f9db89d1f699"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a22786228846e8f4ff6d5f9db89d1f699">QR_QTvec</a> (const size_t M, const size_t N, const mat_t &amp;QR, const vec_t &amp;tau, vec2_t &amp;v)</td></tr>
<tr class="memdesc:a22786228846e8f4ff6d5f9db89d1f699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Form the product Q^T v from a QR factorized matrix. <br/></td></tr>
<tr class="separator:a22786228846e8f4ff6d5f9db89d1f699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d3ef4178dd4cff31de2e3404029957"><td class="memTemplParams" colspan="2"><a class="anchor" id="a92d3ef4178dd4cff31de2e3404029957"></a>
template&lt;class mat1_t , class mat2_t , class mat3_t , class vec_t &gt; </td></tr>
<tr class="memitem:a92d3ef4178dd4cff31de2e3404029957"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a92d3ef4178dd4cff31de2e3404029957">QR_unpack</a> (const size_t M, const size_t N, const mat1_t &amp;QR, const vec_t &amp;tau, mat2_t &amp;Q, mat3_t &amp;R)</td></tr>
<tr class="memdesc:a92d3ef4178dd4cff31de2e3404029957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpack the QR matrix to the individual Q and R components. <br/></td></tr>
<tr class="separator:a92d3ef4178dd4cff31de2e3404029957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da4aa588092693f5fe9471af70199f6"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0da4aa588092693f5fe9471af70199f6"></a>
template&lt;class mat_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a0da4aa588092693f5fe9471af70199f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a0da4aa588092693f5fe9471af70199f6">QR_svx</a> (size_t M, size_t N, const mat_t &amp;QR, const vec_t &amp;tau, vec2_t &amp;x)</td></tr>
<tr class="memdesc:a0da4aa588092693f5fe9471af70199f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the system A x = b in place using the QR factorization. <br/></td></tr>
<tr class="separator:a0da4aa588092693f5fe9471af70199f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e79f2184f8b901e7fb6927c344b6ada"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4e79f2184f8b901e7fb6927c344b6ada"></a>
template&lt;class mat_t , class vec_t , class vec2_t , class vec3_t &gt; </td></tr>
<tr class="memitem:a4e79f2184f8b901e7fb6927c344b6ada"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a4e79f2184f8b901e7fb6927c344b6ada">QR_solve</a> (size_t N, const mat_t &amp;QR, const vec_t &amp;tau, const vec2_t &amp;b, vec3_t &amp;x)</td></tr>
<tr class="memdesc:a4e79f2184f8b901e7fb6927c344b6ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the system A x = b using the QR factorization. <br/></td></tr>
<tr class="separator:a4e79f2184f8b901e7fb6927c344b6ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78da8f058be3e85b901ad9d1a1d671d2"><td class="memTemplParams" colspan="2">template&lt;class mat1_t , class mat2_t , class vec1_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a78da8f058be3e85b901ad9d1a1d671d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a78da8f058be3e85b901ad9d1a1d671d2">QR_update</a> (size_t M, size_t N, mat1_t &amp;Q, mat2_t &amp;R, vec1_t &amp;w, vec2_t &amp;v)</td></tr>
<tr class="memdesc:a78da8f058be3e85b901ad9d1a1d671d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update a QR factorisation for A= Q R, A' = A + u v^T,.  <a href="#a78da8f058be3e85b901ad9d1a1d671d2">More...</a><br/></td></tr>
<tr class="separator:a78da8f058be3e85b901ad9d1a1d671d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab670dc686bfdb814364471e15fec039"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat2_t , class mat3_t &gt; </td></tr>
<tr class="memitem:aab670dc686bfdb814364471e15fec039"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#aab670dc686bfdb814364471e15fec039">QR_decomp_unpack</a> (const size_t M, const size_t N, mat_t &amp;A, mat2_t &amp;Q, mat3_t &amp;R)</td></tr>
<tr class="memdesc:aab670dc686bfdb814364471e15fec039"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the unpacked QR decomposition of matrix <code>A</code>.  <a href="#aab670dc686bfdb814364471e15fec039">More...</a><br/></td></tr>
<tr class="separator:aab670dc686bfdb814364471e15fec039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae2fb75b1a1356209440c033a63b2d2"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0ae2fb75b1a1356209440c033a63b2d2"></a>
template&lt;class mat_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a0ae2fb75b1a1356209440c033a63b2d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a0ae2fb75b1a1356209440c033a63b2d2">QRPT_decomp</a> (size_t M, size_t N, mat_t &amp;A, vec_t &amp;tau, <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;p, int &amp;signum, vec2_t &amp;norm)</td></tr>
<tr class="memdesc:a0ae2fb75b1a1356209440c033a63b2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the QR decomposition of matrix <code>A</code>. <br/></td></tr>
<tr class="separator:a0ae2fb75b1a1356209440c033a63b2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4687b73955364bcecbcc68de772f32ea"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat2_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a4687b73955364bcecbcc68de772f32ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a4687b73955364bcecbcc68de772f32ea">SV_decomp</a> (size_t M, size_t N, mat_t &amp;A, mat2_t &amp;V, vec_t &amp;S, vec2_t &amp;work)</td></tr>
<tr class="memdesc:a4687b73955364bcecbcc68de772f32ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factorise a general matrix into its SV decomposition using the Golub-Reinsch algorithm.  <a href="#a4687b73955364bcecbcc68de772f32ea">More...</a><br/></td></tr>
<tr class="separator:a4687b73955364bcecbcc68de772f32ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc2d7c07fec0f27560462cafe7dff7f"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat2_t , class mat3_t , class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:aecc2d7c07fec0f27560462cafe7dff7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#aecc2d7c07fec0f27560462cafe7dff7f">SV_decomp_mod</a> (size_t M, size_t N, mat_t &amp;A, mat2_t &amp;X, mat3_t &amp;V, vec_t &amp;S, vec2_t &amp;work)</td></tr>
<tr class="memdesc:aecc2d7c07fec0f27560462cafe7dff7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">SV decomposition by the modified Golub-Reinsch algorithm which is better for <img class="formulaInl" alt="$ M \gg N $" src="form_283.png"/>.  <a href="#aecc2d7c07fec0f27560462cafe7dff7f">More...</a><br/></td></tr>
<tr class="separator:aecc2d7c07fec0f27560462cafe7dff7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e3d8b8d2ab10f6fdaccecb8ca1fbdd"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat2_t , class vec_t , class vec2_t , class vec3_t &gt; </td></tr>
<tr class="memitem:ae2e3d8b8d2ab10f6fdaccecb8ca1fbdd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#ae2e3d8b8d2ab10f6fdaccecb8ca1fbdd">SV_solve</a> (size_t M, size_t N, mat_t &amp;U, mat2_t &amp;V, vec_t &amp;S, vec2_t &amp;b, vec3_t &amp;x)</td></tr>
<tr class="memdesc:ae2e3d8b8d2ab10f6fdaccecb8ca1fbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the system A x = b using the SV decomposition.  <a href="#ae2e3d8b8d2ab10f6fdaccecb8ca1fbdd">More...</a><br/></td></tr>
<tr class="separator:ae2e3d8b8d2ab10f6fdaccecb8ca1fbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8ffde83077590ee8a778c6f510070e"><td class="memTemplParams" colspan="2">template&lt;class mat_t , class mat2_t , class vec_t &gt; </td></tr>
<tr class="memitem:a1c8ffde83077590ee8a778c6f510070e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a1c8ffde83077590ee8a778c6f510070e">SV_decomp_jacobi</a> (size_t M, size_t N, mat_t &amp;A, mat2_t &amp;Q, vec_t &amp;S)</td></tr>
<tr class="memdesc:a1c8ffde83077590ee8a778c6f510070e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SV decomposition using one-sided Jacobi orthogonalization.  <a href="#a1c8ffde83077590ee8a778c6f510070e">More...</a><br/></td></tr>
<tr class="separator:a1c8ffde83077590ee8a778c6f510070e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57bdf0238e1809427f63972507e3a57"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad57bdf0238e1809427f63972507e3a57"></a>
template&lt;class mat_t , class vec_t &gt; </td></tr>
<tr class="memitem:ad57bdf0238e1809427f63972507e3a57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#ad57bdf0238e1809427f63972507e3a57">balance_columns</a> (size_t M, size_t N, mat_t &amp;A, vec_t &amp;D)</td></tr>
<tr class="memdesc:ad57bdf0238e1809427f63972507e3a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Balance a general matrix A by scaling the columns by the diagonal matrix D. <br/></td></tr>
<tr class="separator:ad57bdf0238e1809427f63972507e3a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ef037c607bfd107ccfaf7b4cfc66c5"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:a12ef037c607bfd107ccfaf7b4cfc66c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a12ef037c607bfd107ccfaf7b4cfc66c5">chop_small_elements</a> (size_t N, vec_t &amp;d, vec2_t &amp;f)</td></tr>
<tr class="memdesc:a12ef037c607bfd107ccfaf7b4cfc66c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero out small elements in <code>f</code> according to the scales set in <code>d</code>.  <a href="#a12ef037c607bfd107ccfaf7b4cfc66c5">More...</a><br/></td></tr>
<tr class="separator:a12ef037c607bfd107ccfaf7b4cfc66c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8404ace1b30bf263d45fac46a22d0b3"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t &gt; </td></tr>
<tr class="memitem:aa8404ace1b30bf263d45fac46a22d0b3"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#aa8404ace1b30bf263d45fac46a22d0b3">trailing_eigenvalue</a> (size_t n, const vec_t &amp;d, const vec2_t &amp;f)</td></tr>
<tr class="memdesc:aa8404ace1b30bf263d45fac46a22d0b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desc.  <a href="#aa8404ace1b30bf263d45fac46a22d0b3">More...</a><br/></td></tr>
<tr class="separator:aa8404ace1b30bf263d45fac46a22d0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d16f12293d34472bc53435dc91875"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a7c0d16f12293d34472bc53435dc91875">create_schur</a> (double d0, double f0, double d1, double &amp;c, double &amp;s)</td></tr>
<tr class="memdesc:a7c0d16f12293d34472bc53435dc91875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desc.  <a href="#a7c0d16f12293d34472bc53435dc91875">More...</a><br/></td></tr>
<tr class="separator:a7c0d16f12293d34472bc53435dc91875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa360be7ba858d83d1c868c419f19b975"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class mat_t , class mat2_t &gt; </td></tr>
<tr class="memitem:aa360be7ba858d83d1c868c419f19b975"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#aa360be7ba858d83d1c868c419f19b975">svd2</a> (size_t M, size_t N, vec_t &amp;d, vec2_t &amp;f, mat_t &amp;U, mat2_t &amp;V)</td></tr>
<tr class="memdesc:aa360be7ba858d83d1c868c419f19b975"><td class="mdescLeft">&#160;</td><td class="mdescRight">2-variable SVD  <a href="#aa360be7ba858d83d1c868c419f19b975">More...</a><br/></td></tr>
<tr class="separator:aa360be7ba858d83d1c868c419f19b975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa671b123e0da85c5746bb58844530ce2"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class mat_t , class mat2_t &gt; </td></tr>
<tr class="memitem:aa671b123e0da85c5746bb58844530ce2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#aa671b123e0da85c5746bb58844530ce2">svd2_sub</a> (size_t M, size_t N, vec_t &amp;d, vec2_t &amp;f, mat_t &amp;U, mat2_t &amp;V, size_t a)</td></tr>
<tr class="memdesc:aa671b123e0da85c5746bb58844530ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shifted 2-variable SVD.  <a href="#aa671b123e0da85c5746bb58844530ce2">More...</a><br/></td></tr>
<tr class="separator:aa671b123e0da85c5746bb58844530ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458d4b02a2aa6bc533dccb4c80397356"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class mat_t &gt; </td></tr>
<tr class="memitem:a458d4b02a2aa6bc533dccb4c80397356"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a458d4b02a2aa6bc533dccb4c80397356">chase_out_intermediate_zero</a> (size_t M, size_t n, vec_t &amp;d, vec2_t &amp;f, mat_t &amp;U, size_t k0)</td></tr>
<tr class="memdesc:a458d4b02a2aa6bc533dccb4c80397356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desc.  <a href="#a458d4b02a2aa6bc533dccb4c80397356">More...</a><br/></td></tr>
<tr class="separator:a458d4b02a2aa6bc533dccb4c80397356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3214efafd719353088b8629c165f79d9"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class mat_t &gt; </td></tr>
<tr class="memitem:a3214efafd719353088b8629c165f79d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a3214efafd719353088b8629c165f79d9">chase_out_trailing_zero</a> (size_t N, size_t n, vec_t &amp;d, vec2_t &amp;f, mat_t &amp;V)</td></tr>
<tr class="memdesc:a3214efafd719353088b8629c165f79d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desc.  <a href="#a3214efafd719353088b8629c165f79d9">More...</a><br/></td></tr>
<tr class="separator:a3214efafd719353088b8629c165f79d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec59b8dccf3d8e7abd3966f6bc38af87"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class mat_t &gt; </td></tr>
<tr class="memitem:aec59b8dccf3d8e7abd3966f6bc38af87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#aec59b8dccf3d8e7abd3966f6bc38af87">chase_out_trailing_zero_sub</a> (size_t N, size_t n, vec_t &amp;d, vec2_t &amp;f, mat_t &amp;V, size_t a)</td></tr>
<tr class="memdesc:aec59b8dccf3d8e7abd3966f6bc38af87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desc.  <a href="#aec59b8dccf3d8e7abd3966f6bc38af87">More...</a><br/></td></tr>
<tr class="separator:aec59b8dccf3d8e7abd3966f6bc38af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc85032c94252dcdc52c7e62032b0158"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class mat_t , class mat2_t &gt; </td></tr>
<tr class="memitem:afc85032c94252dcdc52c7e62032b0158"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#afc85032c94252dcdc52c7e62032b0158">qrstep</a> (size_t M, size_t N, size_t n, vec_t &amp;d, vec2_t &amp;f, mat_t &amp;U, mat2_t &amp;V)</td></tr>
<tr class="memdesc:afc85032c94252dcdc52c7e62032b0158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Desc.  <a href="#afc85032c94252dcdc52c7e62032b0158">More...</a><br/></td></tr>
<tr class="separator:afc85032c94252dcdc52c7e62032b0158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c32a3b53b3b67c33b87489d1f305f4"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class mat_t , class mat2_t &gt; </td></tr>
<tr class="memitem:ab1c32a3b53b3b67c33b87489d1f305f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#ab1c32a3b53b3b67c33b87489d1f305f4">qrstep_sub</a> (size_t M, size_t N, size_t n, vec_t &amp;d, vec2_t &amp;f, mat_t &amp;U, mat2_t &amp;V, size_t a)</td></tr>
<tr class="memdesc:ab1c32a3b53b3b67c33b87489d1f305f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special form of <a class="el" href="namespaceo2scl__linalg.html#afc85032c94252dcdc52c7e62032b0158" title="Desc. ">qrstep()</a> for <a class="el" href="namespaceo2scl__linalg.html#a4687b73955364bcecbcc68de772f32ea" title="Factorise a general matrix into its SV decomposition using the Golub-Reinsch algorithm. ">SV_decomp()</a>  <a href="#ab1c32a3b53b3b67c33b87489d1f305f4">More...</a><br/></td></tr>
<tr class="separator:ab1c32a3b53b3b67c33b87489d1f305f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfe3209ca2d4b0cdd1f2b2a62357b4e"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class mem_t , class mem_vec_t &gt; </td></tr>
<tr class="memitem:a4bfe3209ca2d4b0cdd1f2b2a62357b4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a4bfe3209ca2d4b0cdd1f2b2a62357b4e">solve_tridiag_sym</a> (const vec_t &amp;diag, const vec2_t &amp;offdiag, const vec3_t &amp;b, vec4_t &amp;x, size_t N, mem_t &amp;m)</td></tr>
<tr class="memdesc:a4bfe3209ca2d4b0cdd1f2b2a62357b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a symmetric tridiagonal linear system with user-specified memory.  <a href="#a4bfe3209ca2d4b0cdd1f2b2a62357b4e">More...</a><br/></td></tr>
<tr class="separator:a4bfe3209ca2d4b0cdd1f2b2a62357b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1722344a69ea7265a16f56c310cee0a"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class vec5_t , class mem_t , class mem_vec_t &gt; </td></tr>
<tr class="memitem:ae1722344a69ea7265a16f56c310cee0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#ae1722344a69ea7265a16f56c310cee0a">solve_tridiag_nonsym</a> (const vec_t &amp;diag, const vec2_t &amp;abovediag, const vec3_t &amp;belowdiag, const vec4_t &amp;rhs, vec5_t &amp;x, size_t N, mem_t &amp;m)</td></tr>
<tr class="memdesc:ae1722344a69ea7265a16f56c310cee0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an asymmetric tridiagonal linear system with user-specified memory.  <a href="#ae1722344a69ea7265a16f56c310cee0a">More...</a><br/></td></tr>
<tr class="separator:ae1722344a69ea7265a16f56c310cee0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591dd2d261378d3dad5ddd530b1e81ec"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class mem_t , class mem_vec_t &gt; </td></tr>
<tr class="memitem:a591dd2d261378d3dad5ddd530b1e81ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a591dd2d261378d3dad5ddd530b1e81ec">solve_cyc_tridiag_sym</a> (const vec_t &amp;diag, const vec2_t &amp;offdiag, const vec3_t &amp;b, vec4_t &amp;x, size_t N, mem_t &amp;m)</td></tr>
<tr class="memdesc:a591dd2d261378d3dad5ddd530b1e81ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a symmetric cyclic tridiagonal linear system with user specified memory.  <a href="#a591dd2d261378d3dad5ddd530b1e81ec">More...</a><br/></td></tr>
<tr class="separator:a591dd2d261378d3dad5ddd530b1e81ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5ca01a596698528724a6b4f7ff2b9a"><td class="memTemplParams" colspan="2">template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class vec5_t , class mem_t , class mem_vec_t &gt; </td></tr>
<tr class="memitem:a5c5ca01a596698528724a6b4f7ff2b9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a5c5ca01a596698528724a6b4f7ff2b9a">solve_cyc_tridiag_nonsym</a> (const vec_t &amp;diag, const vec2_t &amp;abovediag, const vec3_t &amp;belowdiag, const vec4_t &amp;rhs, vec5_t &amp;x, size_t N, mem_t &amp;m)</td></tr>
<tr class="memdesc:a5c5ca01a596698528724a6b4f7ff2b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an asymmetric cyclic tridiagonal linear system with user-specified memory.  <a href="#a5c5ca01a596698528724a6b4f7ff2b9a">More...</a><br/></td></tr>
<tr class="separator:a5c5ca01a596698528724a6b4f7ff2b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daab14c9d2670f1a96f9ac856ad1936"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4daab14c9d2670f1a96f9ac856ad1936"></a>
template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t &gt; </td></tr>
<tr class="memitem:a4daab14c9d2670f1a96f9ac856ad1936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a4daab14c9d2670f1a96f9ac856ad1936">solve_tridiag_sym</a> (const vec_t &amp;diag, const vec2_t &amp;offdiag, const vec3_t &amp;b, vec4_t &amp;x, size_t N)</td></tr>
<tr class="memdesc:a4daab14c9d2670f1a96f9ac856ad1936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a symmetric tridiagonal linear system. <br/></td></tr>
<tr class="separator:a4daab14c9d2670f1a96f9ac856ad1936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150cd9732a35b49c86e99a3e3b96f228"><td class="memTemplParams" colspan="2"><a class="anchor" id="a150cd9732a35b49c86e99a3e3b96f228"></a>
template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class vec5_t &gt; </td></tr>
<tr class="memitem:a150cd9732a35b49c86e99a3e3b96f228"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a150cd9732a35b49c86e99a3e3b96f228">solve_tridiag_nonsym</a> (const vec_t &amp;diag, const vec2_t &amp;abovediag, const vec3_t &amp;belowdiag, const vec4_t &amp;rhs, vec5_t &amp;x, size_t N)</td></tr>
<tr class="memdesc:a150cd9732a35b49c86e99a3e3b96f228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an asymmetric tridiagonal linear system. <br/></td></tr>
<tr class="separator:a150cd9732a35b49c86e99a3e3b96f228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831220db53b8904764ff597931b2be4b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a831220db53b8904764ff597931b2be4b"></a>
template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t &gt; </td></tr>
<tr class="memitem:a831220db53b8904764ff597931b2be4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#a831220db53b8904764ff597931b2be4b">solve_cyc_tridiag_sym</a> (const vec_t &amp;diag, const vec2_t &amp;offdiag, const vec3_t &amp;b, vec4_t &amp;x, size_t N)</td></tr>
<tr class="memdesc:a831220db53b8904764ff597931b2be4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve a symmetric cyclic tridiagonal linear system. <br/></td></tr>
<tr class="separator:a831220db53b8904764ff597931b2be4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af785a50d45ff33ec0f3a6bfd607d8487"><td class="memTemplParams" colspan="2"><a class="anchor" id="af785a50d45ff33ec0f3a6bfd607d8487"></a>
template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class vec5_t &gt; </td></tr>
<tr class="memitem:af785a50d45ff33ec0f3a6bfd607d8487"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceo2scl__linalg.html#af785a50d45ff33ec0f3a6bfd607d8487">solve_cyc_tridiag_nonsym</a> (const vec_t &amp;diag, const vec2_t &amp;abovediag, const vec3_t &amp;belowdiag, const vec4_t &amp;rhs, vec5_t &amp;x, size_t N)</td></tr>
<tr class="memdesc:af785a50d45ff33ec0f3a6bfd607d8487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve an asymmetric cyclic tridiagonal linear system. <br/></td></tr>
<tr class="separator:af785a50d45ff33ec0f3a6bfd607d8487"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9255c444095d57e7c3119efdf558fdf3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat1_t , class mat2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::apply_givens_lq </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat1_t &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This performs <img class="formulaInl" alt="$ Q \rightarrow Q G $" src="form_270.png"/> and <img class="formulaInl" alt="$ L \rightarrow L G^{T} $" src="form_272.png"/>. </p>

<p>Definition at line <a class="el" href="givens__base_8h_source.html#l00086">86</a> of file <a class="el" href="givens__base_8h_source.html">givens_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ea3190e9e6dc21e8fa4a3e832848318"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat1_t , class mat2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::apply_givens_qr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat1_t &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This performs <img class="formulaInl" alt="$ Q \rightarrow Q G $" src="form_270.png"/> and <img class="formulaInl" alt="$ R \rightarrow G^{T} R $" src="form_271.png"/>. </p>

<p>Definition at line <a class="el" href="givens__base_8h_source.html#l00058">58</a> of file <a class="el" href="givens__base_8h_source.html">givens_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a187185f2c949c9122d30018109d29054"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class vec_t , class vec2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::bidiag_decomp </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>tau_U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>tau_V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Factor matrix A of size <code>(M,N)</code> with <img class="formulaInl" alt="$ M\geq N $" src="form_245.png"/> into <img class="formulaInl" alt="$ A = U B V^T $" src="form_246.png"/> where U and V are orthogonal and B is upper bidiagonal.</p>
<p>After the function call, the matrix <img class="formulaInl" alt="$ B $" src="form_247.png"/> is stored the diagonal and first superdiagonal of <code>A</code>. The matrices <img class="formulaInl" alt="$ U $" src="form_248.png"/> and <img class="formulaInl" alt="$ V $" src="form_249.png"/> are stored as packed sets of Householder transformations in the lower and upper triangular parts of <code>A</code>, respectively.</p>
<p>Adapted from the GSL version which was based on algorithm 5.4.2 in <a class="el" href="ref_section.html#GolubXX">GolubXX</a>. </p>

<p>Definition at line <a class="el" href="bidiag__base_8h_source.html#l00065">65</a> of file <a class="el" href="bidiag__base_8h_source.html">bidiag_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3ab3bc3b12150e0a8b158fec36b5320d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class vec_t , class mat2_t , class vec2_t , class mat3_t , class vec3_t , class vec4_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::bidiag_unpack </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>tau_U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec2_t &amp;&#160;</td>
          <td class="paramname"><em>tau_V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat3_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec3_t &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4_t &amp;&#160;</td>
          <td class="paramname"><em>superdiag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a matrix <code>A</code> of size <code>(M,N)</code> with <img class="formulaInl" alt="$ M \geq N $" src="form_250.png"/> created by <a class="el" href="namespaceo2scl__linalg.html#a187185f2c949c9122d30018109d29054">bidiag_decomp()</a>, this function creates the matrix <code>U</code> of size <code>(M,N)</code>, the matrix <code>V</code> of size <code>(N,N)</code>, the diagonal <code>diag</code> of size <code>N</code> and the super-diagonal <code>superdiag</code> of size <code>N-1</code>. </p>

<p>Definition at line <a class="el" href="bidiag__base_8h_source.html#l00113">113</a> of file <a class="el" href="bidiag__base_8h_source.html">bidiag_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a458d4b02a2aa6bc533dccb4c80397356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::chase_out_intermediate_zero </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vector <code>d</code> should be of size <code>n</code>, the vector <code>f</code> should be of size <code>n</code>, and the matrix U should be of size <code>(M,n)</code></p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#afc85032c94252dcdc52c7e62032b0158">qrstep()</a> and <a class="el" href="namespaceo2scl__linalg.html#ab1c32a3b53b3b67c33b87489d1f305f4">qrstep_sub()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00457">457</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3214efafd719353088b8629c165f79d9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::chase_out_trailing_zero </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vector <code>d</code> should be of size <code>n</code>, the vector <code>f</code> should be of size <code>n</code>, and the matrix V should be of size <code>(N,n)</code></p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#afc85032c94252dcdc52c7e62032b0158">qrstep()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00507">507</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="aec59b8dccf3d8e7abd3966f6bc38af87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::chase_out_trailing_zero_sub </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vector <code>d</code> should be of size <code>n</code>, the vector <code>f</code> should be of size <code>n</code>, and the matrix V should be of size <code>(N,n)</code></p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#ab1c32a3b53b3b67c33b87489d1f305f4">qrstep_sub()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00556">556</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4d166572a1cd2e6da85f5d0d50090a61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::cholesky_decomp </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On input, the upper triangular part of A is ignored (only the lower triangular part and diagonal are used). On output, the diagonal and lower triangular part contain the matrix L and the upper triangular part contains L^T.</p>
<p>If the matrix is not positive-definite, the error handler will be called. </p>

<p>Definition at line <a class="el" href="cholesky__base_8h_source.html#l00061">61</a> of file <a class="el" href="cholesky__base_8h_source.html">cholesky_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="afce5f0f6fbab801df7fc63f1200ac027"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::cholesky_invert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>LLT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a Cholesky decomposition produced by <a class="el" href="namespaceo2scl__linalg.html#a4d166572a1cd2e6da85f5d0d50090a61">cholesky_decomp()</a>, this function returns the inverse of that matrix in <code>LLT</code>. </p>

<p>Definition at line <a class="el" href="cholesky__base_8h_source.html#l00204">204</a> of file <a class="el" href="cholesky__base_8h_source.html">cholesky_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c7d4da90e7f9526d06e94c30a3d9d48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class vec_t , class vec2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::cholesky_solve </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>LLT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the Cholesky decomposition of a matrix A in <code>LLT</code>, this function solves the system <code>A*x=b</code>. </p>

<p>Definition at line <a class="el" href="cholesky__base_8h_source.html#l00157">157</a> of file <a class="el" href="cholesky__base_8h_source.html">cholesky_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a12ef037c607bfd107ccfaf7b4cfc66c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::chop_small_elements </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The parameter <code>N</code> is the size of <code>d</code>.</p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#a4687b73955364bcecbcc68de772f32ea">SV_decomp()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00058">58</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c813de822088b1c8ac03818164f2d74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::create_givens </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given values <code>a</code> and <code>b</code>, create entries <code>c</code> and <code>s</code> of a matrix for which </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ \left[ \begin{array}{cc} c &amp; -s \\ s &amp; c \end{array} \right] \left[ \begin{array}{c} a \\ b \end{array} \right] = \left[ \begin{array}{c} r \\ 0 \end{array} \right] \]" src="form_269.png"/>
</p>
 
</div>
</div>
<a class="anchor" id="a7c0d16f12293d34472bc53435dc91875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::create_schur </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>f0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>d1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#aa360be7ba858d83d1c868c419f19b975">svd2()</a> and <a class="el" href="namespaceo2scl__linalg.html#aa671b123e0da85c5746bb58844530ce2">svd2_sub()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00120">120</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8a1780213a3f89789b6c7da494247c4f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::HH_svx </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="future"><dt><b><a class="el" href="future.html#_future000073">Idea for Future:</a></b></dt><dd>Handle memory allocation like the tridiagonal functions. </dd></dl>

<p>Definition at line <a class="el" href="hh__base_8h_source.html#l00059">59</a> of file <a class="el" href="hh__base_8h_source.html">hh_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="acdb8926a8b6dbc52acfb23bef0c9a9c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::householder_hm </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vector <code>v</code> must have at least <code>N</code> entries, with the exception that the vector element <code>v[0]</code> is never referenced by this function. </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00210">210</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="acc4925d6f9b14e01dc75edab912634f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::householder_hm1_sub </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#aecc2d7c07fec0f27560462cafe7dff7f">SV_decomp_mod()</a> and <a class="el" href="namespaceo2scl__linalg.html#a851f79ebab8ed7f2b472712b3496293b">bidiag_unpack2()</a>. </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00436">436</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d082487242d5d892551ab730f7126f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::householder_hm_subcol </td>
          <td>(</td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ir2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ic2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This applies a householder transformation <code>(v,tau)</code> to a lower-right submatrix of <code>M</code>. The submatrix has <code>nr-ir</code> rows and <code>nc-ic</code> columns and starts at row <code>ir</code> of column <code>ic</code> of the original matrix <code>M</code>. The vector containing the transformation is taken from a column of <code>M2</code> starting at row <code>ir2</code> and column <code>ic2</code>. The matrix <code>M2</code> must have at least <code>ic2+1</code> columns and at least <code>nr-ir+ir2</code> rows.</p>
<p>This function is used in <a class="el" href="namespaceo2scl__linalg.html#ac9d84ed3a5e0bff52f863d056ba0894b">QR_decomp()</a> and <a class="el" href="namespaceo2scl__linalg.html#a92d3ef4178dd4cff31de2e3404029957">QR_unpack()</a> . </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00255">255</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a208ce32bd2874399535912e203056e59"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::householder_hm_subrow </td>
          <td>(</td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ir2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ic2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This applies a householder transformation <code>(v,tau)</code> to a lower-right submatrix of <code>M</code>. The submatrix has <code>nr-ir</code> rows and <code>nc-ic</code> columns and starts at row <code>ir</code> of column <code>ic</code> of the original matrix <code>M</code>. The vector containing the transformation is taken from a row of <code>M2</code> starting at row <code>ir2</code> and column <code>ic2</code>. The matrix <code>M2</code> must have at least <code>ir2+1</code> rows and <code>nr-ir+ic2</code> columns.</p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#a3ab3bc3b12150e0a8b158fec36b5320d">bidiag_unpack()</a>. </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00301">301</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1e9031d54a0dd408080bea7d148f5762"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::householder_hv_subcol </td>
          <td>(</td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#a22786228846e8f4ff6d5f9db89d1f699">QR_QTvec()</a>. </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00364">364</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a88d49bbb28e37fcb88408cd58854bd77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::householder_mh_subrow </td>
          <td>(</td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>nc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat2_t &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ir2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ic2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tau</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#a187185f2c949c9122d30018109d29054">bidiag_decomp()</a>. </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00519">519</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5218da1d1a3b97518afcd63eeb7c4b96"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double o2scl_linalg::householder_transform </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On exit, this function returns the value of <img class="formulaInl" alt="$ \tau = 2/ (v^{T} v) $" src="form_274.png"/>. If <code>n</code> is less than or equal to 1 then this function returns zero without calling the error handler. </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00068">68</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a902cb2a01e9961b5745812a46123b17a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double o2scl_linalg::householder_transform_subcol </td>
          <td>(</td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This performs a Householder transform of a vector defined by a column of a matrix <code>A</code> which starts at element <code>A(ir,ic)</code> and ends at element <code>A(M-1,ic)</code>. If <code>M-1</code> is equal to <code>ir+1</code>, this function quietly does nothing.</p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#ac9d84ed3a5e0bff52f863d056ba0894b">QR_decomp()</a> and <a class="el" href="namespaceo2scl__linalg.html#aecc2d7c07fec0f27560462cafe7dff7f">SV_decomp_mod()</a>. </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00118">118</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a173c7179cb0a5be576e9034ca75066c3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double o2scl_linalg::householder_transform_subrow </td>
          <td>(</td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>ic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This performs a Householder transform of a vector defined by a row of a matrix <code>A</code> which starts at element <code>A(ir,ic)</code> and ends at element <code>A(ir,N-1)</code> If <code>N-1</code> is equal to <code>ic</code>, this function quietly does nothing. </p>

<p>Definition at line <a class="el" href="householder__base_8h_source.html#l00165">165</a> of file <a class="el" href="householder__base_8h_source.html">householder_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5973786eb590c5b078d03d763c5054c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::LU_decomp </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>signum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On output the diagonal and upper triangular part of the input matrix A contain the matrix U. The lower triangular part of the input matrix (excluding the diagonal) contains L. The diagonal elements of L are unity, and are not stored.</p>
<p>The permutation matrix P is encoded in the permutation p. The j-th column of the matrix P is given by the k-th column of the identity matrix, where k = p_j the j-th element of the permutation vector. The sign of the permutation is given by signum. It has the value (-1)^n, where n is the number of interchanges in the permutation.</p>
<p>The algorithm used in the decomposition is Gaussian Elimination with partial pivoting (Golub &amp; Van Loan, Matrix Computations, Algorithm 3.4.1).</p>
<dl class="future"><dt><b><a class="el" href="future.html#_future000078">Idea for Future:</a></b></dt><dd>The "swap rows j and i_pivot" section could probably be made more efficient using a "matrix_row"-like object as done in GSL. (7/16/09 - I've tried this, and it doesn't seem to improve the speed significantly.) </dd></dl>

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00086">86</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a90a918ae5c2f983de9835b2bf32e8321"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat_row_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::LU_decomp_alt </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>signum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00185">185</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7955241fbd4a975f2206f4a6a7d012ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double o2scl_linalg::LU_det </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the determinant of a matrix A from its LU decomposition, LU. The determinant is computed as the product of the diagonal elements of U and the sign of the row permutation signum. </p>

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00348">348</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="af8ceda387c6125f2daaa3ec5ff07bca4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat2_t , class mat_col_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::LU_invert </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These functions compute the inverse of a matrix A from its LU decomposition (LU,p), storing the result in the matrix inverse. The inverse is computed by solving the system A x = b for each column of the identity matrix. It is preferable to avoid direct use of the inverse whenever possible, as the linear solver functions can obtain the same result more efficiently and reliably.</p>
<dl class="future"><dt><b><a class="el" href="future.html#_future000079">Idea for Future:</a></b></dt><dd>Could rewrite to avoid mat_col_t, (9/16/09 - However, the function may be faster if mat_col_t is left in, so it's unclear what's best.) </dd></dl>

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00309">309</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1ff6c76948a6ff9e9e5e4d8f3e318a4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double o2scl_linalg::LU_lndet </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>LU</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the logarithm of the absolute value of the determinant of a matrix A, <img class="formulaInl" alt="$ \ln|\det(A)| $" src="form_279.png"/>, from its LU decomposition, LU. This function may be useful if the direct computation of the determinant would overflow or underflow. </p>

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00370">370</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4e422d4448433a6182da5ff37d21ca8f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat2_t , class vec_t , class vec2_t , class vec3_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::LU_refine </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat2_t &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec3_t &amp;&#160;</td>
          <td class="paramname"><em>residual</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These functions apply an iterative improvement to x, the solution of A x = b, using the LU decomposition of A into (LU,p). The initial residual r = A x - b is also computed and stored in residual. </p>

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00271">271</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5bee71f59276e5382c14d3f55dd3b65d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::LU_sgndet </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sign or phase factor of the determinant of a matrix A, <img class="formulaInl" alt="$ \det(A)/|\det(A)| $" src="form_280.png"/>, from its LU decomposition, LU. </p>

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00389">389</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6061c9646e78d3cd469fe5a8f31d5c8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class vec_t , class vec2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::LU_solve </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function solve the square system A x = b using the LU decomposition of A into (LU, p) given by gsl_linalg_LU_decomp or gsl_linalg_complex_LU_decomp. </p>

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00248">248</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="abb6fa6e1a27d9c31b8ee92b1341b01d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int o2scl_linalg::LU_svx </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const mat_t &amp;&#160;</td>
          <td class="paramname"><em>LU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classo2scl_1_1permutation.html">o2scl::permutation</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These functions solve the square system A x = b in-place using the LU decomposition of A into (LU,p). On input x should contain the right-hand side b, which is replaced by the solution on output. </p>

<p>Definition at line <a class="el" href="lu__base_8h_source.html#l00148">148</a> of file <a class="el" href="lu__base_8h_source.html">lu_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="aab670dc686bfdb814364471e15fec039"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat2_t , class mat3_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::QR_decomp_unpack </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat3_t &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If O<span style='position: relative; top: 0.3em; font-size: 0.8em'>2</span>scl  is compiled with Armadillo support, this is specialized for <code>arma::mat</code> to use <code>arma::qr_econ</code>. If O<span style='position: relative; top: 0.3em; font-size: 0.8em'>2</span>scl  is compiled with Eigen support, this is specialized for <code>Eigen::MatrixXd</code>. </p>

<p>Definition at line <a class="el" href="qr__base_8h_source.html#l00231">231</a> of file <a class="el" href="qr__base_8h_source.html">qr_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a78da8f058be3e85b901ad9d1a1d671d2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat1_t , class mat2_t , class vec1_t , class vec2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::QR_update </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat1_t &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec1_t &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The parameters <code>M</code> and <code>N</code> are the number of rows and columns of the matrix <code>R</code>.</p>
<pre class="fragment">* Q' R' = QR + u v^T
*       = Q (R + Q^T u v^T)
*       = Q (R + w v^T)
*
* where w = Q^T u.
*
* Algorithm from Golub and Van Loan, "Matrix Computations", Section
* 12.5 (Updating Matrix Factorizations, Rank-One Changes)
</pre> 
<p>Definition at line <a class="el" href="qr__base_8h_source.html#l00165">165</a> of file <a class="el" href="qr__base_8h_source.html">qr_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="afc85032c94252dcdc52c7e62032b0158"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class mat_t , class mat2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::qrstep </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vector <code>d</code> should be of size <code>n</code>, the vector <code>f</code> should be of size <code>n</code>, the matrix U should be of size <code>(M,N)</code>, and the matrix <code>V</code> should be of size <code>(N,N)</code>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00603">603</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab1c32a3b53b3b67c33b87489d1f305f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class mat_t , class mat2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::qrstep_sub </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The vector <code>d</code> should be of size <code>n</code>, the vector <code>f</code> should be of size <code>n</code>, the matrix U should be of size <code>(M,n)</code>, and the matrix <code>V</code> should be of size <code>(N,n)</code>.</p>
<p>A version of <a class="el" href="namespaceo2scl__linalg.html#afc85032c94252dcdc52c7e62032b0158" title="Desc. ">qrstep()</a>, but starting at the a'th column of U, the a'th column of V, and the a'th entries of <code>d</code> and <code>f</code>.</p>
<p>This function is used by <a class="el" href="namespaceo2scl__linalg.html#a4687b73955364bcecbcc68de772f32ea">SV_decomp()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00762">762</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c5ca01a596698528724a6b4f7ff2b9a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class vec5_t , class mem_t , class mem_vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::solve_cyc_tridiag_nonsym </td>
          <td>(</td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec2_t &amp;&#160;</td>
          <td class="paramname"><em>abovediag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec3_t &amp;&#160;</td>
          <td class="paramname"><em>belowdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4_t &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec5_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mem_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function solves the system <img class="formulaInl" alt="$ A x = b $" src="form_278.png"/> where <img class="formulaInl" alt="$ A $" src="form_276.png"/> is a matrix of the form </p>
<pre class="fragment">*
*        diag[0]  abovediag[0]             0   .....  belowdiag[N-1]
*   belowdiag[0]       diag[1]  abovediag[1]   .....
*              0  belowdiag[1]       diag[2]
*              0             0  belowdiag[2]   .....
*            ...           ...
* abovediag[N-1]           ...
</pre><p>This function solves the following system without the corner elements and then use Sherman-Morrison formula to compensate for them.</p>
<dl class="future"><dt><b><a class="el" href="future.html#_future000082">Idea for Future:</a></b></dt><dd>Offer an option to avoid throwing on divide by zero? </dd></dl>

<p>Definition at line <a class="el" href="tridiag__base_8h_source.html#l00338">338</a> of file <a class="el" href="tridiag__base_8h_source.html">tridiag_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a591dd2d261378d3dad5ddd530b1e81ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class mem_t , class mem_vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::solve_cyc_tridiag_sym </td>
          <td>(</td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec2_t &amp;&#160;</td>
          <td class="paramname"><em>offdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec3_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mem_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function solves the system <img class="formulaInl" alt="$ A x = b $" src="form_278.png"/> where <img class="formulaInl" alt="$ A $" src="form_276.png"/> is a matrix of the form </p>
<pre class="fragment">*
*      diag[0]  offdiag[0]             0   .....  offdiag[N-1]
*   offdiag[0]     diag[1]    offdiag[1]   .....
*            0  offdiag[1]       diag[2]
*            0           0    offdiag[2]   .....
*          ...         ...
* offdiag[N-1]         ...
</pre><p>See <a class="el" href="ref_section.html#EngelnMullges96">EngelnMullges96</a> . </p>

<p>Definition at line <a class="el" href="tridiag__base_8h_source.html#l00241">241</a> of file <a class="el" href="tridiag__base_8h_source.html">tridiag_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae1722344a69ea7265a16f56c310cee0a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class vec5_t , class mem_t , class mem_vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::solve_tridiag_nonsym </td>
          <td>(</td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec2_t &amp;&#160;</td>
          <td class="paramname"><em>abovediag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec3_t &amp;&#160;</td>
          <td class="paramname"><em>belowdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec4_t &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec5_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mem_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function solves the system <img class="formulaInl" alt="$ A x = b $" src="form_278.png"/> where <img class="formulaInl" alt="$ A $" src="form_276.png"/> is a matrix of the form </p>
<pre class="fragment">* 
*       diag[0]  abovediag[0]             0   .....
*  belowdiag[0]       diag[1]  abovediag[1]   .....
*             0  belowdiag[1]       diag[2]
*             0             0  belowdiag[2]   .....
</pre><p> This function uses plain Gauss elimination, not bothering with the zeroes.</p>
<dl class="future"><dt><b><a class="el" href="future.html#_future000081">Idea for Future:</a></b></dt><dd>Offer an option to avoid throwing on divide by zero? </dd></dl>

<p>Definition at line <a class="el" href="tridiag__base_8h_source.html#l00183">183</a> of file <a class="el" href="tridiag__base_8h_source.html">tridiag_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4bfe3209ca2d4b0cdd1f2b2a62357b4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class vec3_t , class vec4_t , class mem_t , class mem_vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::solve_tridiag_sym </td>
          <td>(</td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec2_t &amp;&#160;</td>
          <td class="paramname"><em>offdiag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec3_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec4_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mem_t &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function solves the system <img class="formulaInl" alt="$ A x = b $" src="form_278.png"/> where <img class="formulaInl" alt="$ A $" src="form_276.png"/> is a matrix of the form </p>
<pre class="fragment">*
*     diag[0]  offdiag[0]             0   .....
*  offdiag[0]     diag[1]    offdiag[1]   .....
*           0  offdiag[1]       diag[2]
*           0           0    offdiag[2]   .....
</pre><p> given the <code>N</code> diagonal elements in <code>diag</code>, <code>N-1</code> diagonal elements in <code>offdiag</code>, and the <code>N</code> elements <code>b</code> from the RHS.</p>
<p>See <a class="el" href="ref_section.html#EngelnMullges96">EngelnMullges96</a> . </p>

<p>Definition at line <a class="el" href="tridiag__base_8h_source.html#l00118">118</a> of file <a class="el" href="tridiag__base_8h_source.html">tridiag_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4687b73955364bcecbcc68de772f32ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat2_t , class vec_t , class vec2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::SV_decomp </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This factors matrix <code>A</code> of size <code>(M,N)</code> into </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = U~D~V^T \]" src="form_281.png"/>
</p>
<p> where <code>U</code> is a column-orthogonal matrix of size <code>(M,N)</code> (stored in <code>A</code>), <code>D</code> is a diagonal matrix of size <code>(N,N)</code> (stored in the vector <code>S</code> of size <code>N</code>), and <code>V</code> is a orthogonal matrix of size <code>(N,N)</code>. The vector <code>work</code> is a workspace vector of size <code>N</code>. The matrices <code>U</code> and <code>V</code> are constructed so that </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ U^T~U = I \qquad \mathrm{and} \qquad V^T~V = V~V^T = I \]" src="form_282.png"/>
</p>
<p>This algorithm requres <img class="formulaInl" alt="$ M \geq N $" src="form_250.png"/>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>Test N=1 case, N=2 case, and non-square matrices. </dd></dl>

<p>Definition at line <a class="el" href="svd__base_8h_source.html#l00073">73</a> of file <a class="el" href="svd__base_8h_source.html">svd_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c8ffde83077590ee8a778c6f510070e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat2_t , class vec_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::SV_decomp_jacobi </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This factors matrix <code>A</code> of size <code>(M,N)</code> into </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = U~D~V^T \]" src="form_281.png"/>
</p>
<p> where <code>U</code> is a column-orthogonal matrix of size <code>(M,N)</code> (stored in <code>A</code>), <code>D</code> is a diagonal matrix of size <code>(N,N)</code> (stored in the vector <code>S</code> of size <code>N</code>), and <code>V</code> is a orthogonal matrix of size <code>(N,N)</code>.</p>
<p>This function computes singular values to higher relative accuracy than <a class="el" href="namespaceo2scl__linalg.html#a4687b73955364bcecbcc68de772f32ea">SV_decomp()</a> and <a class="el" href="namespaceo2scl__linalg.html#aecc2d7c07fec0f27560462cafe7dff7f">SV_decomp_mod()</a>.</p>
<dl class="future"><dt><b><a class="el" href="future.html#_future000080">Idea for Future:</a></b></dt><dd>There were originally a few GSL_COERCE_DBL calls which have been temporarily removed and could be restored. </dd></dl>

<p>Definition at line <a class="el" href="svd__base_8h_source.html#l00438">438</a> of file <a class="el" href="svd__base_8h_source.html">svd_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="aecc2d7c07fec0f27560462cafe7dff7f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat2_t , class mat3_t , class vec_t , class vec2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::SV_decomp_mod </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat3_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>work</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This factors matrix <code>A</code> of size <code>(M,N)</code> into </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = U~D~V^T \]" src="form_281.png"/>
</p>
<p> where <code>U</code> is a column-orthogonal matrix of size <code>(M,N)</code> (stored in <code>A</code>), <code>D</code> is a diagonal matrix of size <code>(N,N)</code> (stored in the vector <code>S</code> of size <code>N</code>), and <code>V</code> is a orthogonal matrix of size <code>(N,N)</code>. The vector <code>work</code> is a workspace vector of size <code>N</code> and the matrix <code>X</code> is a workspace of size <code>(N,N)</code>. </p>

<p>Definition at line <a class="el" href="svd__base_8h_source.html#l00290">290</a> of file <a class="el" href="svd__base_8h_source.html">svd_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae2e3d8b8d2ab10f6fdaccecb8ca1fbdd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class mat_t , class mat2_t , class vec_t , class vec2_t , class vec3_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::SV_solve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec3_t &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves a linear system using the output of <a class="el" href="namespaceo2scl__linalg.html#a4687b73955364bcecbcc68de772f32ea">SV_decomp()</a>. Only non-zero singular values are used in computing solution. In the over-determined case, <img class="formulaInl" alt="$ M>N $" src="form_284.png"/>, the system is solved in the least-squares sense. </p>

<p>Definition at line <a class="el" href="svd__base_8h_source.html#l00373">373</a> of file <a class="el" href="svd__base_8h_source.html">svd_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa360be7ba858d83d1c868c419f19b975"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class mat_t , class mat2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::svd2 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The parameter <code>M</code> is the number of rows in <code>U</code> and <code>N</code> is the number of rows in <code>V</code>. Both U and V assumed to have two columns.</p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#afc85032c94252dcdc52c7e62032b0158">qrstep()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00176">176</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa671b123e0da85c5746bb58844530ce2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t , class mat_t , class mat2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void o2scl_linalg::svd2_sub </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat_t &amp;&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mat2_t &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The parameter <code>M</code> is the number of rows in <code>U</code> and <code>N</code> is the number of rows in <code>V</code>. Both U and V assumed to have two columns.</p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#ab1c32a3b53b3b67c33b87489d1f305f4">qrstep_sub()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00316">316</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa8404ace1b30bf263d45fac46a22d0b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class vec_t , class vec2_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double o2scl_linalg::trailing_eigenvalue </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec_t &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vec2_t &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The parameter <code>n</code> is the size of the vector <code>d</code>.</p>
<p>Used in <a class="el" href="namespaceo2scl__linalg.html#afc85032c94252dcdc52c7e62032b0158">qrstep()</a> and <a class="el" href="namespaceo2scl__linalg.html#ab1c32a3b53b3b67c33b87489d1f305f4">qrstep_sub()</a>. </p>

<p>Definition at line <a class="el" href="svdstep__base_8h_source.html#l00085">85</a> of file <a class="el" href="svdstep__base_8h_source.html">svdstep_base.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/>
<p>Documentation generated with <a
href="http://www.doxygen.org">Doxygen</a>. Provided under the
GNU Free Documentation License (see <a
href="license_section.html">License Information</a>).<br>
Hosted at <a href="http://sourceforge.net/projects/o2scl">
<img src="http://sflogo.sourceforge.net/sflogo.php?group_id=206918&amp;type=10"
width="80" height="15" alt="Get Object-oriented Scientific Computing
Lib at SourceForge.net. Fast, secure and Free Open Source software
downloads." /></a>. </p>
<!-- Piwik -->
<script type="text/javascript">
var pkBaseURL = (("https:" == document.location.protocol) ? "https://sourceforge.net/apps/piwik/o2scl/" : "http://sourceforge.net/apps/piwik/o2scl/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
</script><script type="text/javascript">
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
</script><noscript><p><img src="http://sourceforge.net/apps/piwik/o2scl/piwik.php?idsite=1" style="border:0" alt=""/></p></noscript>
<!-- End Piwik Tag -->
</body>
</html>
